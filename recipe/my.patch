diff --git a/CMakeLists.txt b/CMakeLists.txt
index 106903715..5aa161319 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -332,11 +332,11 @@ if(ENABLE_BLAS_LAPACK)
       # blas/lapack libs (useful for users with no Fortran compiler and no MKL
       # license, who can just download our precompiled "gmsh-dep" package)
       if(HAVE_64BIT_SIZE_T)
-        set(MKL_PATH em64t/lib)
-        set(MKL_LIBS_REQUIRED libguide40 mkl_intel_lp64 mkl_intel_thread mkl_core)
+        set(MKL_PATH Library/lib)
+        set(MKL_LIBS_REQUIRED mkl_intel_lp64_dll mkl_intel_thread_dll mkl_core_dll)
       else(HAVE_64BIT_SIZE_T)
-        set(MKL_PATH ia32/lib)
-        set(MKL_LIBS_REQUIRED libguide40 mkl_intel_c mkl_intel_thread mkl_core)
+        set(MKL_PATH Library/lib)
+        set(MKL_LIBS_REQUIRED mkl_intel_c_dll mkl_intel_thread_dll mkl_core_dll)
       endif(HAVE_64BIT_SIZE_T)
       find_all_libraries(LAPACK_LIBRARIES MKL_LIBS_REQUIRED "" ${MKL_PATH})
       if(LAPACK_LIBRARIES)
@@ -491,7 +491,7 @@ if(ENABLE_FLTK)
   if(FLTK_CONFIG_SCRIPT)
     execute_process(COMMAND ${FLTK_CONFIG_SCRIPT} --api-version
                     OUTPUT_VARIABLE FLTK_VERSION)
-    string(STRIP ${FLTK_VERSION} FLTK_VERSION)
+    string(STRIP "${FLTK_VERSION}" FLTK_VERSION)
     if(FLTK_VERSION GREATER 1.1)
       add_subdirectory(Fltk)
       set_config_option(HAVE_FLTK "Fltk")
diff --git a/Geo/GModel.cpp b/Geo/GModel.cpp
index 297271c8e..a5e406fe5 100644
--- a/Geo/GModel.cpp
+++ b/Geo/GModel.cpp
@@ -595,7 +595,7 @@ bool GModel::getBoundaryTags(const std::vector<std::pair<int, int> > &inDimTags,
       int dim = outDimTags[i].first;
       int tag = outDimTags[i].second;
       if(dim >= 0 && dim < 3){
-        std::set<int>::iterator it = c[dim].find(tag);
+        std::set<int,AbsIntLessThan>::iterator it = c[dim].find(tag);
         if(it == c[dim].end())
           c[dim].insert(tag);
         else{
@@ -605,7 +605,7 @@ bool GModel::getBoundaryTags(const std::vector<std::pair<int, int> > &inDimTags,
     }
     outDimTags.clear();
     for(int dim = 0; dim < 3; dim++){
-      for(std::set<int>::iterator it = c[dim].begin(); it != c[dim].end(); it++)
+      for(std::set<int,AbsIntLessThan>::iterator it = c[dim].begin(); it != c[dim].end(); it++)
         outDimTags.push_back(std::pair<int, int>(dim, *it));
     }
   }
@@ -823,7 +823,7 @@ static void addToMap
    std::map< MElement *, std::vector < std::pair <MElement *, bool> > > &elToNeighbors,
    const MFace &face,  MElement *el)
 {
-  std::map< MFace , MElement *, Less_Face>::iterator fit = faceToElement.find(face);
+  std::multimap< MFace , MElement *, Less_Face>::iterator fit = faceToElement.find(face);
   if (fit == faceToElement.end()){
     faceToElement.insert(std::pair< MFace , MElement *>(face, el));
   }
@@ -2364,7 +2364,7 @@ void GModel::alignPeriodicBoundaries()
 
         MFace tgtFace(vtcs);
 
-        std::map<MFace,MElement*>::iterator mIter = srcElmts.find(tgtFace);
+        std::map<MFace,MElement*,Less_Face>::iterator mIter = srcElmts.find(tgtFace);
         if (mIter == srcElmts.end()) {
           std::ostringstream faceDef;
           for (int iVtx=0;iVtx<nbVtcs;iVtx++) {
diff --git a/Geo/discreteDiskFace.h b/Geo/discreteDiskFace.h
index 676745680..19680d01f 100644
--- a/Geo/discreteDiskFace.h
+++ b/Geo/discreteDiskFace.h
@@ -132,7 +132,7 @@ class triangulation {
     }
 
     std::map<MVertex*,std::vector<MVertex*> > firstNode2Edge;
-    for (std::set<MEdge>::iterator ie = borderEdg.begin(); ie != borderEdg.end() ; ++ie) {
+    for (std::set<MEdge,Less_Edge>::iterator ie = borderEdg.begin(); ie != borderEdg.end() ; ++ie) {
       MEdge ed = *ie;
       const std::vector<int> &nT = ed2tri[ed];
       MElement* t = tri[nT[0]];
diff --git a/Geo/discreteFace.cpp b/Geo/discreteFace.cpp
index dc8225617..cbc34b57b 100644
--- a/Geo/discreteFace.cpp
+++ b/Geo/discreteFace.cpp
@@ -665,7 +665,7 @@ void discreteFace::updateTopology(std::vector<triangulation*>&partition)
       std::map<MVertex*,MLine*> v02edg;//first vertex of the MLine
       std::set<MVertex*> first, last;
       const std::set<MEdge,Less_Edge> &bii = partition[ii]->borderEdg;// edges defining the border(s) of the ii-th new triangulation
-      for(std::set<MEdge,Less_Edge>::iterator ie = bordi.begin(); ie != bordi.end(); ++ie){// MEdge by MEdge of the i-th triangulation border(s)
+      for(std::set<MEdge,Less_Edge>::const_iterator ie = bordi.begin(); ie != bordi.end(); ++ie){// MEdge by MEdge of the i-th triangulation border(s)
 	if(bii.find(*ie)!=bii.end()){// if the border edge is common to both triangulations, then it is a future GEdge - composed of MLine's
 	  v02edg[ie->getVertex(0)] = new MLine(ie->getVertex(0),ie->getVertex(1));// a new MLine is created
 
